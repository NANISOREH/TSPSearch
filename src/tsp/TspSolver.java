package tsp;

import tsp.algorithms.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

/*This class has static methods to allow the client to start the search with one of the implemented algorithms
 */
public class TspSolver {
    private static int cores = Runtime.getRuntime().availableProcessors();
    private List<City> cities;
    private static final int restarts = 10;

    /* Public facade method used by the client to start the default algorithm, Simulated Annealing
    * */
    public static Tour solve (List<City> cities) throws InterruptedException {
        return launchSA(cities);
    }

    /* Public facade method used by the client to start an algorithm of its choice
    * */
    public static Tour solve (List<City> cities, Algorithm algorithm) throws InterruptedException {
        switch (algorithm) {
            case HILL_CLIMBING: return launchHC(cities);
            case BRUTE_FORCE: return launchBF(cities);
            case HILL_CLIMBING_RANDOM_RESTARTS: return launchHCRR(cities, restarts);
            case SIMULATED_ANNEALING: return launchSA(cities);
            case GENETIC_SEARCH: return launchGS(cities);
            default : return launchHC(cities);
        }
    }

    /* Launches a single instance of Hill Climbing search and returns the resulting Tour.
     * For "a single instance" I mean it will do as many searches as the number of cores on the machine and pick the best.
     * It's not exactly a single search, but the additional searches are basicly for free thanks to multithreading magic,
     * so why da hell not?*/
    private static Tour launchHC (List<City> cities) throws InterruptedException {

        ArrayList<HillClimbing> threads = new ArrayList<>();
        for (int i=0; i<cores; i++) {
            threads.add(new HillClimbing(cities));
        }

        for (HillClimbing t : threads) {
            t.start();
        }
        for (HillClimbing t : threads) {
            t.join();
        }

        return HillClimbing.getBest();
    }

    /*Launches a certain number of random restarts of hill climbing search, determined by the "restarts" parameter.
    * The actual number of restarts is equal to restarts multiplied by the number of cores in the machine.
    * Returns the best Tour among those generated by the searches.
    * */
    private static Tour launchHCRR (List<City> cities, int restarts) throws InterruptedException {

        ArrayList<HillClimbing> threads = new ArrayList<>();
        int tCount;

        for (tCount = 0; tCount < cores; tCount++) {
            threads.add(tCount, new HillClimbing(cities));
        }

        ScheduledThreadPoolExecutor pool = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4);
        for (tCount = 0; tCount < cores; tCount++) {
            pool.scheduleWithFixedDelay(threads.get(tCount), 1, 1, TimeUnit.MILLISECONDS);
        }
        while (true) {
            if (pool.getCompletedTaskCount() >= restarts * cores) {
                pool.shutdownNow();
                return HillClimbing.getBest();
            }
        }
    }

    /*Launches a brute force search.
    * It's single threaded because it would be a massive waste of time to parallelize it internally.
    * Nobody is going to execute it on NASA's computers and on normal machines it's impractical in any case.
    * It's useful to check for the optimal solution on smaller inputs and compare local searches with it.
    * */
    private static Tour launchBF (List<City> cities) throws InterruptedException {

        BruteForce thread = new BruteForce(cities);
        thread.start();
        thread.join();

        return BruteForce.getBest();
    }

    private static Tour launchGS (List<City> cities) throws InterruptedException {

        ArrayList<GeneticSearch> threads = new ArrayList<>();
        for (int i=0; i<cores; i++) {
            threads.add(new GeneticSearch(cities));
        }

        for (GeneticSearch t : threads) {
            t.start();
        }
        for (GeneticSearch t : threads) {
            t.join();
        }

        return GeneticSearch.getBest();
    }

    /* Launches a single instance of Simulated Annealing search and returns the resulting Tour.
     * For "a single instance" I mean it will do as many searches as the number of cores on the machine and pick the best.
     * It's not exactly a single search, but the additional searches are basicly for free thanks to multithreading magic,
     * so why da hell not?*/
    private static Tour launchSA (List<City> cities) throws InterruptedException {

        ArrayList<SimulatedAnnealing> threads = new ArrayList<>();
        for (int i=0; i<cores; i++) {
            threads.add(new SimulatedAnnealing(cities));
        }

        for (SimulatedAnnealing t : threads) {
            t.start();
        }
        for (SimulatedAnnealing t : threads) {
            t.join();
        }

        return SimulatedAnnealing.getBest();
    }

}
