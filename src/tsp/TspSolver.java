package tsp;

import tsp.algorithms.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

/*This class has methods to allow the client to configure and start the search with one of the implemented algorithms
 */
public class TspSolver {
    private static final int cores = Runtime.getRuntime().availableProcessors();
    private int restarts = 10;

    //The meaning of these parameters is explained in the GeneticSearch class implementing the actual algorithm
    private int populationSize = 2000;
    private int tournamentRounds = 2;
    private double mutationProbability = 0.01;
    private double elitismRate = 0.05;
    private int maxUnluckyRuns = 600;
    private long timeBudget = 3600000L;

    //The meaning of these parameters is explained in the SimulatedAnnealing class implementing the actual algorithm
    private double temperature = 10000;
    private double coolingFactor = 0.99996;

    private TspSolver () {}

    public static TspSolver getSolver() {
        return new TspSolver();
    }

    /*This method lets the client configure the parameter needed for the execution of HCRR algorithm
    * It returns a TspSolver, so it can be used in oneliners like:
    * Tour solution = TspSolver.getSolver().configure(parameter).solve(algorithm)
    * */
    public TspSolver configureHCRR(int restarts) {
        this.restarts = restarts;
        return this;
    }

    /*This method lets the client configure the parameter needed for the execution of SA algorithm
     * It returns a TspSolver, so it can be used in oneliners like:
     * Tour solution = TspSolver.getSolver().configure(parameter1,...,parameterN).solve(algorithm)
     * */
    public TspSolver configureSA(double temperature, double coolingFactor) {
        this.temperature = temperature;
        this.coolingFactor = coolingFactor;
        return this;
    }

     /*This method lets the client configure the parameters needed for the execution of GS algorithm
     * It returns a TspSolver, so it can be used in oneliners like:
     * Tour solution = TspSolver.getSolver().configure(parameter1,..., parameterN).solve(algorithm)
     * */
    public TspSolver configureGS(int populationSize, int tournamentRounds, double mutationProbability,
                               double elitismRate, int maxUnluckyRuns, long timeBudget) {
        this.populationSize = populationSize;
        this.tournamentRounds = tournamentRounds;
        this.mutationProbability = mutationProbability;
        this.elitismRate = elitismRate;
        this.maxUnluckyRuns = maxUnluckyRuns;
        this.timeBudget = timeBudget;
        return this;
    }

    /* Public facade method used by the client to start the default algorithm, Simulated Annealing
    * */
    public Tour search (List<City> cities) throws InterruptedException {
        return launchSA(cities);
    }

    /* Public facade method used by the client to start an algorithm of its choice.
       If the client launches a configurable algorithm without calling a configuration method first, default values will be used.
    * */
    public Tour search (List<City> cities, Algorithm algorithm) throws InterruptedException {
        switch (algorithm) {
            case HILL_CLIMBING: return launchHC(cities);
            case BRUTE_FORCE: return launchBF(cities);
            case HILL_CLIMBING_RANDOM_RESTARTS: return launchHCRR(cities, restarts);
            case SIMULATED_ANNEALING: return launchSA(cities);
            case GENETIC_SEARCH: return launchGS(cities);
            default : return new Tour();
        }
    }

    /* Launches a single instance of Hill Climbing search and returns the resulting Tour.
     * For "a single instance" I mean it will do as many searches as the number of cores on the machine and pick the best result.
     * It's not exactly a single search, but the additional searches are basicly for free thanks to multithreading magic,
     * so why da hell not?*/
    private Tour launchHC (List<City> cities) throws InterruptedException {

        ArrayList<HillClimbing> threads = new ArrayList<>();
        for (int i=0; i<cores; i++) {
            threads.add(new HillClimbing(cities));
        }

        for (HillClimbing t : threads) {
            t.start();
        }
        for (HillClimbing t : threads) {
            t.join();
        }

        return HillClimbing.getBest();
    }

    /*Launches a certain number of random restarts of hill climbing search, determined by the "restarts" parameter.
    * The actual number of restarts is equal to restarts multiplied by the number of cores in the machine.
    * Returns the best Tour among those generated by the searches.
    * */
    private Tour launchHCRR (List<City> cities, int restarts) {

        ArrayList<HillClimbing> threads = new ArrayList<>();
        int tCount;

        for (tCount = 0; tCount < cores; tCount++) {
            threads.add(tCount, new HillClimbing(cities));
        }

        ScheduledThreadPoolExecutor pool = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4);
        for (tCount = 0; tCount < cores; tCount++) {
            pool.scheduleWithFixedDelay(threads.get(tCount), 1, 1, TimeUnit.MILLISECONDS);
        }
        while (true) {
            if (pool.getCompletedTaskCount() >= restarts * cores) {
                pool.shutdownNow();
                return HillClimbing.getBest();
            }
        }
    }

    /*Launches a brute force search.
    * It's single threaded because it would be a massive waste of time to parallelize it internally.
    * Nobody is going to execute it on NASA's computers and on normal machines it's impractical in any case.
    * It's useful to check for the optimal solution on smaller inputs and compare local searches with it.
    * */
    private Tour launchBF (List<City> cities) throws InterruptedException {

        BruteForce thread = new BruteForce(cities);
        thread.start();
        thread.join();

        return BruteForce.getBest();
    }

    /* Launches a single instance of a very bad genetic search algorithm and returns the resulting Tour.
     * For "a single instance" I mean it will do as many searches as the number of cores on the machine and pick the best result.
     * It's not exactly a single search, but the additional searches are basicly for free thanks to multithreading magic,
     * so why da hell not?*/
    private Tour launchGS (List<City> cities) throws InterruptedException {

        ArrayList<GeneticSearch> threads = new ArrayList<>();
        for (int i=0; i<cores; i++) {
            threads.add(new GeneticSearch(cities));
        }

        for (GeneticSearch t : threads) {
            t.setParameters(this.populationSize, this.tournamentRounds, this.mutationProbability, this.elitismRate, this.maxUnluckyRuns, this.timeBudget);
            t.start();
        }
        for (GeneticSearch t : threads) {
            t.join();
        }

        return GeneticSearch.getBest();
    }

    /* Launches a single instance of Simulated Annealing search and returns the resulting Tour.
     * For "a single instance" I mean it will do as many searches as the number of cores on the machine and pick the best.
     * It's not exactly a single search, but the additional searches are basicly for free thanks to multithreading magic,
     * so why da hell not?*/
    private Tour launchSA (List<City> cities) throws InterruptedException {

        ArrayList<SimulatedAnnealing> threads = new ArrayList<>();
        for (int i=0; i<cores; i++) {
            threads.add(new SimulatedAnnealing(cities));
        }

        for (SimulatedAnnealing t : threads) {
            t.setParameters(this.temperature, this.coolingFactor);
            t.start();
        }
        for (SimulatedAnnealing t : threads) {
            t.join();
        }

        return SimulatedAnnealing.getBest();
    }

}
